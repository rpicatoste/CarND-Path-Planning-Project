{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"tar",
				"target_x"
			],
			[
				"previou",
				"previous_path_x"
			],
			[
				"previo",
				"previous_path_x"
			],
			[
				"shit",
				"shift_y"
			],
			[
				"ref_y",
				"ref_y_prev"
			],
			[
				"ref_x",
				"ref_x_prev"
			],
			[
				"ref",
				"ref_x"
			],
			[
				"pre",
				"prev_size-1"
			],
			[
				"ptsy",
				"previous_path_y"
			],
			[
				"prev_",
				"prev_size"
			],
			[
				"map",
				"map_waypoints_y"
			],
			[
				"map_",
				"map_waypoints_x"
			],
			[
				"nex",
				"next_d"
			],
			[
				"ne",
				"next_s"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "#include <fstream>\n#include <math.h>\n#include <uWS/uWS.h>\n#include <chrono>\n#include <iostream>\n#include <thread>\n#include <vector>\n#include \"Eigen-3.3/Eigen/Core\"\n#include \"Eigen-3.3/Eigen/QR\"\n#include \"json.hpp\"\n\n#include \"spline.h\"\n\nusing namespace std;\n\n// for convenience\nusing json = nlohmann::json;\n\n// For converting back and forth between radians and degrees.\nconstexpr double pi() { return M_PI; }\ndouble deg2rad(double x) { return x * pi() / 180; }\ndouble rad2deg(double x) { return x * 180 / pi(); }\n\n// Checks if the SocketIO event has JSON data.\n// If there is data the JSON object in string format will be returned,\n// else the empty string \"\" will be returned.\nstring hasData(string s) {\n  auto found_null = s.find(\"null\");\n  auto b1 = s.find_first_of(\"[\");\n  auto b2 = s.find_first_of(\"}\");\n  if (found_null != string::npos) {\n    return \"\";\n  } else if (b1 != string::npos && b2 != string::npos) {\n    return s.substr(b1, b2 - b1 + 2);\n  }\n  return \"\";\n}\n\ndouble distance(double x1, double y1, double x2, double y2)\n{\n\treturn sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n}\nint ClosestWaypoint(double x, double y, const vector<double> &maps_x, const vector<double> &maps_y)\n{\n\n\tdouble closestLen = 100000; //large number\n\tint closestWaypoint = 0;\n\n\tfor(int i = 0; i < maps_x.size(); i++)\n\t{\n\t\tdouble map_x = maps_x[i];\n\t\tdouble map_y = maps_y[i];\n\t\tdouble dist = distance(x,y,map_x,map_y);\n\t\tif(dist < closestLen)\n\t\t{\n\t\t\tclosestLen = dist;\n\t\t\tclosestWaypoint = i;\n\t\t}\n\n\t}\n\n\treturn closestWaypoint;\n\n}\n\nint NextWaypoint(double x, double y, double theta, const vector<double> &maps_x, const vector<double> &maps_y)\n{\n\n\tint closestWaypoint = ClosestWaypoint(x,y,maps_x,maps_y);\n\n\tdouble map_x = maps_x[closestWaypoint];\n\tdouble map_y = maps_y[closestWaypoint];\n\n\tdouble heading = atan2((map_y-y),(map_x-x));\n\n\tdouble angle = fabs(theta-heading);\n  angle = min(2*pi() - angle, angle);\n\n  if(angle > pi()/4)\n  {\n    closestWaypoint++;\n  if (closestWaypoint == maps_x.size())\n  {\n    closestWaypoint = 0;\n  }\n  }\n\n  return closestWaypoint;\n}\n\n// Transform from Cartesian x,y coordinates to Frenet s,d coordinates\nvector<double> getFrenet(double x, double y, double theta, const vector<double> &maps_x, const vector<double> &maps_y)\n{\n\tint next_wp = NextWaypoint(x,y, theta, maps_x,maps_y);\n\n\tint prev_wp;\n\tprev_wp = next_wp-1;\n\tif(next_wp == 0)\n\t{\n\t\tprev_wp  = maps_x.size()-1;\n\t}\n\n\tdouble n_x = maps_x[next_wp]-maps_x[prev_wp];\n\tdouble n_y = maps_y[next_wp]-maps_y[prev_wp];\n\tdouble x_x = x - maps_x[prev_wp];\n\tdouble x_y = y - maps_y[prev_wp];\n\n\t// find the projection of x onto n\n\tdouble proj_norm = (x_x*n_x+x_y*n_y)/(n_x*n_x+n_y*n_y);\n\tdouble proj_x = proj_norm*n_x;\n\tdouble proj_y = proj_norm*n_y;\n\n\tdouble frenet_d = distance(x_x,x_y,proj_x,proj_y);\n\n\t//see if d value is positive or negative by comparing it to a center point\n\n\tdouble center_x = 1000-maps_x[prev_wp];\n\tdouble center_y = 2000-maps_y[prev_wp];\n\tdouble centerToPos = distance(center_x,center_y,x_x,x_y);\n\tdouble centerToRef = distance(center_x,center_y,proj_x,proj_y);\n\n\tif(centerToPos <= centerToRef)\n\t{\n\t\tfrenet_d *= -1;\n\t}\n\n\t// calculate s value\n\tdouble frenet_s = 0;\n\tfor(int i = 0; i < prev_wp; i++)\n\t{\n\t\tfrenet_s += distance(maps_x[i],maps_y[i],maps_x[i+1],maps_y[i+1]);\n\t}\n\n\tfrenet_s += distance(0,0,proj_x,proj_y);\n\n\treturn {frenet_s,frenet_d};\n\n}\n\n// Transform from Frenet s,d coordinates to Cartesian x,y\nvector<double> getXY(double s, double d, const vector<double> &maps_s, const vector<double> &maps_x, const vector<double> &maps_y)\n{\n\tint prev_wp = -1;\n\n\twhile(s > maps_s[prev_wp+1] && (prev_wp < (int)(maps_s.size()-1) ))\n\t{\n\t\tprev_wp++;\n\t}\n\n\tint wp2 = (prev_wp+1)%maps_x.size();\n\n\tdouble heading = atan2((maps_y[wp2]-maps_y[prev_wp]),(maps_x[wp2]-maps_x[prev_wp]));\n\t// the x,y,s along the segment\n\tdouble seg_s = (s-maps_s[prev_wp]);\n\n\tdouble seg_x = maps_x[prev_wp]+seg_s*cos(heading);\n\tdouble seg_y = maps_y[prev_wp]+seg_s*sin(heading);\n\n\tdouble perp_heading = heading-pi()/2;\n\n\tdouble x = seg_x + d*cos(perp_heading);\n\tdouble y = seg_y + d*sin(perp_heading);\n\n\treturn {x,y};\n\n}\n\nint main() {\n  uWS::Hub h;\n\n  // Load up map values for waypoint's x,y,s and d normalized normal vectors\n  vector<double> map_waypoints_x;\n  vector<double> map_waypoints_y;\n  vector<double> map_waypoints_s;\n  vector<double> map_waypoints_dx;\n  vector<double> map_waypoints_dy;\n\n  // Waypoint map to read from\n  string map_file_ = \"../data/highway_map.csv\";\n  // The max s value before wrapping around the track back to 0\n  double max_s = 6945.554;\n\n  ifstream in_map_(map_file_.c_str(), ifstream::in);\n\n  string line;\n  while (getline(in_map_, line)) {\n  \tistringstream iss(line);\n  \tdouble x;\n  \tdouble y;\n  \tfloat s;\n  \tfloat d_x;\n  \tfloat d_y;\n  \tiss >> x;\n  \tiss >> y;\n  \tiss >> s;\n  \tiss >> d_x;\n  \tiss >> d_y;\n  \tmap_waypoints_x.push_back(x);\n  \tmap_waypoints_y.push_back(y);\n  \tmap_waypoints_s.push_back(s);\n  \tmap_waypoints_dx.push_back(d_x);\n  \tmap_waypoints_dy.push_back(d_y);\n  }\n\n  // Start in lane 1\n  int lane = 1;\n\n  // Have a reference velocity to target\n  double ref_vel = 49.5; // mph\n\n  h.onMessage([&map_waypoints_x,&map_waypoints_y,&map_waypoints_s,&map_waypoints_dx,&map_waypoints_dy](uWS::WebSocket<uWS::SERVER> ws, char *data, size_t length,\n                     uWS::OpCode opCode) {\n    // \"42\" at the start of the message means there's a websocket message event.\n    // The 4 signifies a websocket message\n    // The 2 signifies a websocket event\n    //auto sdata = string(data).substr(0, length);\n    //cout << sdata << endl;\n    if (length && length > 2 && data[0] == '4' && data[1] == '2') {\n\n      auto s = hasData(data);\n\n      if (s != \"\") {\n        auto j = json::parse(s);\n        \n        string event = j[0].get<string>();\n        \n        if (event == \"telemetry\") {\n          // j[1] is the data JSON object\n          \n        \t// Main car's localization Data\n          \tdouble car_x = j[1][\"x\"];\n          \tdouble car_y = j[1][\"y\"];\n          \tdouble car_s = j[1][\"s\"];\n          \tdouble car_d = j[1][\"d\"];\n          \tdouble car_yaw = j[1][\"yaw\"];\n          \tdouble car_speed = j[1][\"speed\"];\n\n          \t// Previous path data given to the Planner\n          \tauto previous_path_x = j[1][\"previous_path_x\"];\n          \tauto previous_path_y = j[1][\"previous_path_y\"];\n          \t// Previous path's end s and d values \n          \tdouble end_path_s = j[1][\"end_path_s\"];\n          \tdouble end_path_d = j[1][\"end_path_d\"];\n\n          \t// Sensor Fusion Data, a list of all other cars on the same side of the road.\n          \tauto sensor_fusion = j[1][\"sensor_fusion\"];\n\n\n            int prev_size = previous_path_x.size();\n\n          \tjson msgJson;\n\n          \tvector<double> next_x_vals;\n          \tvector<double> next_y_vals;\n\n\n          \t// TODO: define a path made up of (x,y) points that the car will visit sequentially every .02 seconds\n            // Create very spaced (30m) waypoints, then interpolate with spline.\n            vector<double> ptsx;\n            vector<double> ptsy;\n\n\n            double ref_x = car_x;\n            double ref_y = car_y;\n            double ref_yaw = deg2rad(car_yaw);\n\n\n            if(prev_size < 2){\n              // Use 2 points that make the path tangent to de car.\n              double prev_car_x = car_x - cos(car_yaw);\n              double prev_car_y = car_y - sin(car_yaw);              \n\n              ptsx.push_back(prev_car_x);\n              ptsx.push_back(car_x);              \n\n              ptsy.push_back(prev_car_y);\n              ptsy.push_back(car_y);              \n            }\n            // use the previous path's end point as starting reference\n            else{\n              // Redefine\n              ref_x = previous_path_x[prev_size-1];\n              ref_y = previous_path_y[prev_size-1];\n\n              double ref_x_prev = previous_path_x[prev_size-2];\n              double ref_y_prev = previous_path_y[prev_size-2];\n              ref_yaw = atan2(ref_y - ref_y_prev, ref_x - ref_x_prev );\n\n              // Use 2 points that make the path tangent to the previous path's end point\n              ptsx.push_back(ref_x_prev);\n              ptsx.push_back(ref_x);              \n\n              ptsy.push_back(ref_y_prev);\n              ptsy.push_back(ref_y);   \n            }\n\n            vector<double> next_wp0 = getXY(car_s + 30,\n                                            (2+4*lane),\n                                            map_waypoints_s,\n                                            map_waypoints_x,\n                                            map_waypoints_y);\n            vector<double> next_wp1 = getXY(car_s + 60,\n                                            (2+4*lane),\n                                            map_waypoints_s,\n                                            map_waypoints_x,\n                                            map_waypoints_y);\n            vector<double> next_wp2 = getXY(car_s + 90,\n                                            (2+4*lane),\n                                            map_waypoints_s,\n                                            map_waypoints_x,\n                                            map_waypoints_y);\n\n            ptsx.push_back(next_wp0[0]);            \n            ptsx.push_back(next_wp1[0]);\n            ptsx.push_back(next_wp2[0]);\n\n            ptsy.push_back(next_wp0[1]);\n            ptsy.push_back(next_wp1[1]);\n            ptsy.push_back(next_wp2[1]);\n\n\n            for(int ii = 0; ii < ptsx.size(); ii++){\n              // shift car reference angle to 0 degrees\n              double shift_x = ptsx[ii] - ref_x;\n              double shift_y = ptsy[ii] - ref_y;\n\n              ptsx[ii] = (shift_x * cos(0-ref_yaw) - shift_y * sin(0-ref_yaw));\n              ptsy[ii] = (shift_x * sin(0-ref_yaw) + shift_y * cos(0-ref_yaw));\n\n            }\n\n            // Create a spline\n            tk:: spline s;\n\n            // Set (x,y) points to the spline\n            s.set_points(ptsx, ptsy);\n\n            // Define the actual (x,y) points we will use for the planner\n            vector<double> next_x_vals;\n            vector<double> next_y_vals;\n\n            // Start with all of the previous path points from last time\n            for (int ii = 0; ii < previous_path_x.size(); ii++){\n              next_x_vals.push_back(previous_path_x[ii]);\n              next_y_vals.push_back(previous_path_y[ii]);\n            }\n\n            // Calculate hot to break up spline points so that we travel at our desired reference velocity\n            double target_x = 30.0;\n            double target_y = s(target_x);\n            double target_dist = sqrt( (target_x)*(target_x) + (target_y)*(target_y) );\n\n            double x_add_on = 0;\n\n\n\n\n /*\n            double dist_inc = 0.5;\n            double delta_car_yaw = 40.0/50.0;\n            \n            for(int i = 0; i < 50; i++)\n            {\n              double next_s = car_s + (i+1)*dist_inc;\n              double next_d = car_d;\n\n              vector<double> xy = getXY(next_s, next_d, map_waypoints_s, map_waypoints_x, map_waypoints_y); \n\n              next_x_vals.push_back(xy[0]);\n              next_y_vals.push_back(xy[1]);\n            }\n*/\n\n\n          \tmsgJson[\"next_x\"] = next_x_vals;\n          \tmsgJson[\"next_y\"] = next_y_vals;\n\n          \tauto msg = \"42[\\\"control\\\",\"+ msgJson.dump()+\"]\";\n\n          \t//this_thread::sleep_for(chrono::milliseconds(1000));\n          \tws.send(msg.data(), msg.length(), uWS::OpCode::TEXT);\n          \n        }\n      } else {\n        // Manual driving\n        std::string msg = \"42[\\\"manual\\\",{}]\";\n        ws.send(msg.data(), msg.length(), uWS::OpCode::TEXT);\n      }\n    }\n  });\n\n  // We don't need this since we're not using HTTP but if it's removed the\n  // program\n  // doesn't compile :-(\n  h.onHttpRequest([](uWS::HttpResponse *res, uWS::HttpRequest req, char *data,\n                     size_t, size_t) {\n    const std::string s = \"<h1>Hello world!</h1>\";\n    if (req.getUrl().valueLength == 1) {\n      res->end(s.data(), s.length());\n    } else {\n      // i guess this should be done more gracefully?\n      res->end(nullptr, 0);\n    }\n  });\n\n  h.onConnection([&h](uWS::WebSocket<uWS::SERVER> ws, uWS::HttpRequest req) {\n    std::cout << \"Connected!!!\" << std::endl;\n  });\n\n  h.onDisconnection([&h](uWS::WebSocket<uWS::SERVER> ws, int code,\n                         char *message, size_t length) {\n    ws.close();\n    std::cout << \"Disconnected\" << std::endl;\n  });\n\n  int port = 4567;\n  if (h.listen(port)) {\n    std::cout << \"Listening to port \" << port << std::endl;\n  } else {\n    std::cerr << \"Failed to listen to port\" << std::endl;\n    return -1;\n  }\n  h.run();\n}\n",
			"file": "src/main.cpp",
			"file_size": 12695,
			"file_write_time": 131567821597586694,
			"settings":
			{
				"buffer_size": 12593,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/D/Ricardo/Google Drive/Study/Self Driving Car Nanodegree/Term 3/CarND-Path-Planning-Project",
		"/D/Ricardo/Google Drive/Study/Self Driving Car Nanodegree/Term 3/CarND-Path-Planning-Project/src"
	],
	"file_history":
	[
		"/D/Ricardo/Google Drive/Study/Self Driving Car Nanodegree/Term 3/L1,2,3,4,5,6 Path Planning/L4/behavior_planner/src/road.h",
		"/D/Ricardo/Google Drive/Study/Self Driving Car Nanodegree/Term 3/L1,2,3,4,5,6 Path Planning/L4/behavior_planner/src/vehicle.cpp",
		"/D/Ricardo/Google Drive/Study/Self Driving Car Nanodegree/Term 3/L1,2,3,4,5,6 Path Planning/L4/behavior_planner/src/road.cpp",
		"/D/Ricardo/Google Drive/Study/Self Driving Car Nanodegree/Term 3/L1,2,3,4,5,6 Path Planning/L4/behavior_planner/src/main.cpp",
		"/D/Ricardo/Google Drive/Study/Self Driving Car Nanodegree/Term 3/L1,2,3,4,5,6 Path Planning/L4/test.py"
	],
	"find":
	{
		"height": 49.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			";\n"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/main.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12593,
						"regions":
						{
						},
						"selection":
						[
							[
								10661,
								10661
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"word_wrap": true
						},
						"translation.x": 0.0,
						"translation.y": 2800.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 22.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "path_planning.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 180.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
